{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["// 'path' module extracted from Node.js v8.11.1 (only the posix part)\nimport type Path from 'node:path'\n\nexport const path:typeof Path = {\n    // path.resolve([from ...], to)\n    resolve: function resolve (...args) {\n        let resolvedPath = ''\n        let resolvedAbsolute = false\n        let cwd\n\n        for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            let path\n            if (i >= 0) {\n                path = args[i]\n            } else {\n                if (cwd === undefined) {\n                    cwd = (process?.cwd() || '/')\n                }\n                path = cwd\n            }\n\n            assertPath(path)\n\n            // Skip empty entries\n            if (path.length === 0) {\n                continue\n            }\n\n            resolvedPath = path + '/' + resolvedPath\n            resolvedAbsolute = path.charCodeAt(0) === 47 /* / */\n        }\n\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n\n        // Normalize the path\n        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute)\n\n        if (resolvedAbsolute) {\n            if (resolvedPath.length > 0) { return '/' + resolvedPath } else { return '/' }\n        } else if (resolvedPath.length > 0) {\n            return resolvedPath\n        } else {\n            return '.'\n        }\n    },\n\n    normalize: function normalize (path) {\n        assertPath(path)\n\n        if (path.length === 0) return '.'\n\n        const isAbsolute = path.charCodeAt(0) === 47 /* / */\n        const trailingSeparator = path.charCodeAt(path.length - 1) === 47 /* / */\n\n        // Normalize the path\n        path = normalizeStringPosix(path, !isAbsolute)\n\n        if (path.length === 0 && !isAbsolute) path = '.'\n        if (path.length > 0 && trailingSeparator) path += '/'\n\n        if (isAbsolute) return '/' + path\n        return path\n    },\n\n    isAbsolute: function isAbsolute (path) {\n        assertPath(path)\n        return path.length > 0 && path.charCodeAt(0) === 47 /* / */\n    },\n\n    join: function join (...args) {\n        if (arguments.length === 0) { return '.' }\n        let joined\n        for (let i = 0; i < arguments.length; ++i) {\n            const arg = args[i]\n            assertPath(arg)\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg\n                } else {\n                    joined += '/' + arg\n                }\n            }\n        }\n        if (joined === undefined) { return '.' }\n\n        return path.normalize(joined)\n    },\n\n    relative: function relative (from, to) {\n        assertPath(from)\n        assertPath(to)\n\n        if (from === to) return ''\n\n        from = path.resolve(from)\n        to = path.resolve(to)\n\n        if (from === to) return ''\n\n        // Trim any leading backslashes\n        let fromStart = 1\n        for (; fromStart < from.length; ++fromStart) {\n            if (from.charCodeAt(fromStart) !== 47 /* / */) { break }\n        }\n        const fromEnd = from.length\n        const fromLen = fromEnd - fromStart\n\n        // Trim any leading backslashes\n        let toStart = 1\n        for (; toStart < to.length; ++toStart) {\n            if (to.charCodeAt(toStart) !== 47 /* / */) { break }\n        }\n        const toEnd = to.length\n        const toLen = toEnd - toStart\n\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen\n        let lastCommonSep = -1\n        let i = 0\n        for (; i <= length; ++i) {\n            if (i === length) {\n                if (toLen > length) {\n                    if (to.charCodeAt(toStart + i) === 47 /* / */) {\n                        // We get here if `from` is the exact base path for `to`.\n                        // For example: from='/foo/bar'; to='/foo/bar/baz'\n                        return to.slice(toStart + i + 1)\n                    } else if (i === 0) {\n                        // We get here if `from` is the root\n                        // For example: from='/'; to='/foo'\n                        return to.slice(toStart + i)\n                    }\n                } else if (fromLen > length) {\n                    if (from.charCodeAt(fromStart + i) === 47 /* / */) {\n                        // We get here if `to` is the exact base path for `from`.\n                        // For example: from='/foo/bar/baz'; to='/foo/bar'\n                        lastCommonSep = i\n                    } else if (i === 0) {\n                        // We get here if `to` is the root.\n                        // For example: from='/foo'; to='/'\n                        lastCommonSep = 0\n                    }\n                }\n                break\n            }\n            const fromCode = from.charCodeAt(fromStart + i)\n            const toCode = to.charCodeAt(toStart + i)\n            if (fromCode !== toCode) { break } else if (fromCode === 47 /* / */) { lastCommonSep = i }\n        }\n\n        let out = ''\n        // Generate the relative path based on the path difference between `to`\n        // and `from`\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === 47 /* / */) {\n                if (out.length === 0) { out += '..' } else { out += '/..' }\n            }\n        }\n\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts\n        if (out.length > 0) { return out + to.slice(toStart + lastCommonSep) } else {\n            toStart += lastCommonSep\n            if (to.charCodeAt(toStart) === 47 /* / */) { ++toStart }\n            return to.slice(toStart)\n        }\n    },\n\n    _makeLong: function _makeLong (path) {\n        return path\n    },\n\n    dirname: function dirname (path) {\n        assertPath(path)\n        if (path.length === 0) return '.'\n        let code = path.charCodeAt(0)\n        const hasRoot = code === 47 /* / */\n        let end = -1\n        let matchedSlash = true\n        for (let i = path.length - 1; i >= 1; --i) {\n            code = path.charCodeAt(i)\n            if (code === 47 /* / */) {\n                if (!matchedSlash) {\n                    end = i\n                    break\n                }\n            } else {\n                // We saw the first non-path separator\n                matchedSlash = false\n            }\n        }\n\n        if (end === -1) return hasRoot ? '/' : '.'\n        if (hasRoot && end === 1) return '//'\n        return path.slice(0, end)\n    },\n\n    basename: function basename (path, ext) {\n        if (ext !== undefined && typeof ext !== 'string') {\n            throw new TypeError('\"ext\" argument must be a string')\n        }\n        assertPath(path)\n\n        let start = 0\n        let end = -1\n        let matchedSlash = true\n        let i\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext.length === path.length && ext === path) return ''\n            let extIdx = ext.length - 1\n            let firstNonSlashEnd = -1\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i)\n                if (code === 47 /* / */) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1\n                        break\n                    }\n                } else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false\n                        firstNonSlashEnd = i + 1\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i\n                            }\n                        } else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1\n                            end = firstNonSlashEnd\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length\n            return path.slice(start, end)\n        } else {\n            for (i = path.length - 1; i >= 0; --i) {\n                if (path.charCodeAt(i) === 47 /* / */) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1\n                        break\n                    }\n                } else if (end === -1) {\n                    // We saw the first non-path separator, mark this as the end of our\n                    // path component\n                    matchedSlash = false\n                    end = i + 1\n                }\n            }\n\n            if (end === -1) return ''\n            return path.slice(start, end)\n        }\n    },\n\n    extname: function extname (path) {\n        assertPath(path)\n        let startDot = -1\n        let startPart = 0\n        let end = -1\n        let matchedSlash = true\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i)\n            if (code === 47 /* / */) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1\n                    break\n                }\n                continue\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false\n                end = i + 1\n            }\n            if (code === 46 /* . */) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) { startDot = i } else if (preDotState !== 1) { preDotState = 1 }\n            } else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (\n                preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1\n            )\n        ) {\n            return ''\n        }\n\n        return path.slice(startDot, end)\n    },\n\n    format: function format (pathObject) {\n        if (pathObject === null || typeof pathObject !== 'object') {\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject)\n        }\n        return _format('/', pathObject)\n    },\n\n    parse: function parse (path) {\n        assertPath(path)\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' }\n        if (path.length === 0) return ret\n        let code = path.charCodeAt(0)\n        const isAbsolute = code === 47 /* / */\n        let start\n        if (isAbsolute) {\n            ret.root = '/'\n            start = 1\n        } else {\n            start = 0\n        }\n        let startDot = -1\n        let startPart = 0\n        let end = -1\n        let matchedSlash = true\n        let i = path.length - 1\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0\n\n        // Get non-dir info\n        for (; i >= start; --i) {\n            code = path.charCodeAt(i)\n            if (code === 47 /* / */) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1\n                    break\n                }\n                continue\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false\n                end = i + 1\n            }\n            if (code === 46 /* . */) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i; else if (preDotState !== 1) preDotState = 1\n            } else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (\n                preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1\n            )\n        ) {\n            if (end !== -1) {\n                if (startPart === 0 && isAbsolute) {\n                    ret.base = ret.name = path.slice(1, end)\n                } else {\n                    ret.base = ret.name = path.slice(startPart, end)\n                }\n            }\n        } else {\n            if (startPart === 0 && isAbsolute) {\n                ret.name = path.slice(1, startDot)\n                ret.base = path.slice(1, end)\n            } else {\n                ret.name = path.slice(startPart, startDot)\n                ret.base = path.slice(startPart, end)\n            }\n            ret.ext = path.slice(startDot, end)\n        }\n\n        if (startPart > 0) ret.dir = path.slice(0, startPart - 1); else if (isAbsolute) ret.dir = '/'\n\n        return ret\n    },\n\n    sep: '/',\n    delimiter: ':',\n    // @ts-expect-error skip this\n    win32: null,\n    // @ts-expect-error skip this\n    posix: null\n}\n\n// @ts-expect-error read only error b/c node types\npath.posix = path\n\nfunction assertPath (path) {\n    if (typeof path !== 'string') {\n        throw new TypeError(\n            'Path must be a string. Received ' + JSON.stringify(path)\n        )\n    }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix (path, allowAboveRoot) {\n    let res = ''\n    let lastSegmentLength = 0\n    let lastSlash = -1\n    let dots = 0\n    let code\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) { code = path.charCodeAt(i) } else if (code === 47 /* / */) { break } else { code = 47 } /* / */\n        if (code === 47 /* / */) {\n            if (lastSlash === i - 1 || dots === 1) {\n                // NOOP\n            } else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /* . */ || res.charCodeAt(res.length - 2) !== 46 /* . */) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf('/')\n                        if (lastSlashIndex !== res.length - 1) {\n                            if (lastSlashIndex === -1) {\n                                res = ''\n                                lastSegmentLength = 0\n                            } else {\n                                res = res.slice(0, lastSlashIndex)\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/')\n                            }\n                            lastSlash = i\n                            dots = 0\n                            continue\n                        }\n                    } else if (res.length === 2 || res.length === 1) {\n                        res = ''\n                        lastSegmentLength = 0\n                        lastSlash = i\n                        dots = 0\n                        continue\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) { res += '/..' } else { res = '..' }\n                    lastSegmentLength = 2\n                }\n            } else {\n                if (res.length > 0) { res += '/' + path.slice(lastSlash + 1, i) } else { res = path.slice(lastSlash + 1, i) }\n                lastSegmentLength = i - lastSlash - 1\n            }\n            lastSlash = i\n            dots = 0\n        } else if (code === 46 /* . */ && dots !== -1) {\n            ++dots\n        } else {\n            dots = -1\n        }\n    }\n    return res\n}\n\nfunction _format (sep, pathObject) {\n    const dir = pathObject.dir || pathObject.root\n    const base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '')\n    if (!dir) {\n        return base\n    }\n    if (dir === pathObject.root) {\n        return dir + base\n    }\n    return dir + sep + base\n}\n\nexport default path\n"],
  "mappings": "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",
  "names": ["path", "isAbsolute"]
}
