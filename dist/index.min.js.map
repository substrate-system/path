{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["// 'path' module extracted from Node.js v8.11.1 (only the posix part)\nimport type Path from 'node:path'\n\nexport const path:typeof Path = {\n    // path.resolve([from ...], to)\n    resolve: function resolve (...args) {\n        let resolvedPath = ''\n        let resolvedAbsolute = false\n        let cwd\n\n        for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            let path\n            if (i >= 0) {\n                path = args[i]\n            } else {\n                if (cwd === undefined) {\n                    cwd = (process?.cwd() || '/')\n                }\n                path = cwd\n            }\n\n            assertPath(path)\n\n            // Skip empty entries\n            if (path.length === 0) {\n                continue\n            }\n\n            resolvedPath = path + '/' + resolvedPath\n            resolvedAbsolute = path.charCodeAt(0) === 47 /* / */\n        }\n\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n\n        // Normalize the path\n        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute)\n\n        if (resolvedAbsolute) {\n            if (resolvedPath.length > 0) { return '/' + resolvedPath } else { return '/' }\n        } else if (resolvedPath.length > 0) {\n            return resolvedPath\n        } else {\n            return '.'\n        }\n    },\n\n    normalize: function normalize (path) {\n        assertPath(path)\n\n        if (path.length === 0) return '.'\n\n        const isAbsolute = path.charCodeAt(0) === 47 /* / */\n        const trailingSeparator = path.charCodeAt(path.length - 1) === 47 /* / */\n\n        // Normalize the path\n        path = normalizeStringPosix(path, !isAbsolute)\n\n        if (path.length === 0 && !isAbsolute) path = '.'\n        if (path.length > 0 && trailingSeparator) path += '/'\n\n        if (isAbsolute) return '/' + path\n        return path\n    },\n\n    isAbsolute: function isAbsolute (path) {\n        assertPath(path)\n        return path.length > 0 && path.charCodeAt(0) === 47 /* / */\n    },\n\n    join: function join (...args) {\n        if (arguments.length === 0) { return '.' }\n        let joined\n        for (let i = 0; i < arguments.length; ++i) {\n            const arg = args[i]\n            assertPath(arg)\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg\n                } else {\n                    joined += '/' + arg\n                }\n            }\n        }\n        if (joined === undefined) { return '.' }\n\n        return path.normalize(joined)\n    },\n\n    relative: function relative (from, to) {\n        assertPath(from)\n        assertPath(to)\n\n        if (from === to) return ''\n\n        from = path.resolve(from)\n        to = path.resolve(to)\n\n        if (from === to) return ''\n\n        // Trim any leading backslashes\n        let fromStart = 1\n        for (; fromStart < from.length; ++fromStart) {\n            if (from.charCodeAt(fromStart) !== 47 /* / */) { break }\n        }\n        const fromEnd = from.length\n        const fromLen = fromEnd - fromStart\n\n        // Trim any leading backslashes\n        let toStart = 1\n        for (; toStart < to.length; ++toStart) {\n            if (to.charCodeAt(toStart) !== 47 /* / */) { break }\n        }\n        const toEnd = to.length\n        const toLen = toEnd - toStart\n\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen\n        let lastCommonSep = -1\n        let i = 0\n        for (; i <= length; ++i) {\n            if (i === length) {\n                if (toLen > length) {\n                    if (to.charCodeAt(toStart + i) === 47 /* / */) {\n                        // We get here if `from` is the exact base path for `to`.\n                        // For example: from='/foo/bar'; to='/foo/bar/baz'\n                        return to.slice(toStart + i + 1)\n                    } else if (i === 0) {\n                        // We get here if `from` is the root\n                        // For example: from='/'; to='/foo'\n                        return to.slice(toStart + i)\n                    }\n                } else if (fromLen > length) {\n                    if (from.charCodeAt(fromStart + i) === 47 /* / */) {\n                        // We get here if `to` is the exact base path for `from`.\n                        // For example: from='/foo/bar/baz'; to='/foo/bar'\n                        lastCommonSep = i\n                    } else if (i === 0) {\n                        // We get here if `to` is the root.\n                        // For example: from='/foo'; to='/'\n                        lastCommonSep = 0\n                    }\n                }\n                break\n            }\n            const fromCode = from.charCodeAt(fromStart + i)\n            const toCode = to.charCodeAt(toStart + i)\n            if (fromCode !== toCode) { break } else if (fromCode === 47 /* / */) { lastCommonSep = i }\n        }\n\n        let out = ''\n        // Generate the relative path based on the path difference between `to`\n        // and `from`\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === 47 /* / */) {\n                if (out.length === 0) { out += '..' } else { out += '/..' }\n            }\n        }\n\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts\n        if (out.length > 0) { return out + to.slice(toStart + lastCommonSep) } else {\n            toStart += lastCommonSep\n            if (to.charCodeAt(toStart) === 47 /* / */) { ++toStart }\n            return to.slice(toStart)\n        }\n    },\n\n    _makeLong: function _makeLong (path) {\n        return path\n    },\n\n    dirname: function dirname (path) {\n        assertPath(path)\n        if (path.length === 0) return '.'\n        let code = path.charCodeAt(0)\n        const hasRoot = code === 47 /* / */\n        let end = -1\n        let matchedSlash = true\n        for (let i = path.length - 1; i >= 1; --i) {\n            code = path.charCodeAt(i)\n            if (code === 47 /* / */) {\n                if (!matchedSlash) {\n                    end = i\n                    break\n                }\n            } else {\n                // We saw the first non-path separator\n                matchedSlash = false\n            }\n        }\n\n        if (end === -1) return hasRoot ? '/' : '.'\n        if (hasRoot && end === 1) return '//'\n        return path.slice(0, end)\n    },\n\n    basename: function basename (path, ext) {\n        if (ext !== undefined && typeof ext !== 'string') {\n            throw new TypeError('\"ext\" argument must be a string')\n        }\n        assertPath(path)\n\n        let start = 0\n        let end = -1\n        let matchedSlash = true\n        let i\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext.length === path.length && ext === path) return ''\n            let extIdx = ext.length - 1\n            let firstNonSlashEnd = -1\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i)\n                if (code === 47 /* / */) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1\n                        break\n                    }\n                } else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false\n                        firstNonSlashEnd = i + 1\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i\n                            }\n                        } else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1\n                            end = firstNonSlashEnd\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length\n            return path.slice(start, end)\n        } else {\n            for (i = path.length - 1; i >= 0; --i) {\n                if (path.charCodeAt(i) === 47 /* / */) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1\n                        break\n                    }\n                } else if (end === -1) {\n                    // We saw the first non-path separator, mark this as the end of our\n                    // path component\n                    matchedSlash = false\n                    end = i + 1\n                }\n            }\n\n            if (end === -1) return ''\n            return path.slice(start, end)\n        }\n    },\n\n    extname: function extname (path) {\n        assertPath(path)\n        let startDot = -1\n        let startPart = 0\n        let end = -1\n        let matchedSlash = true\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i)\n            if (code === 47 /* / */) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1\n                    break\n                }\n                continue\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false\n                end = i + 1\n            }\n            if (code === 46 /* . */) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) { startDot = i } else if (preDotState !== 1) { preDotState = 1 }\n            } else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (\n                preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1\n            )\n        ) {\n            return ''\n        }\n\n        return path.slice(startDot, end)\n    },\n\n    format: function format (pathObject) {\n        if (pathObject === null || typeof pathObject !== 'object') {\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject)\n        }\n        return _format('/', pathObject)\n    },\n\n    parse: function parse (path) {\n        assertPath(path)\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' }\n        if (path.length === 0) return ret\n        let code = path.charCodeAt(0)\n        const isAbsolute = code === 47 /* / */\n        let start\n        if (isAbsolute) {\n            ret.root = '/'\n            start = 1\n        } else {\n            start = 0\n        }\n        let startDot = -1\n        let startPart = 0\n        let end = -1\n        let matchedSlash = true\n        let i = path.length - 1\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0\n\n        // Get non-dir info\n        for (; i >= start; --i) {\n            code = path.charCodeAt(i)\n            if (code === 47 /* / */) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1\n                    break\n                }\n                continue\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false\n                end = i + 1\n            }\n            if (code === 46 /* . */) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i; else if (preDotState !== 1) preDotState = 1\n            } else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (\n                preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1\n            )\n        ) {\n            if (end !== -1) {\n                if (startPart === 0 && isAbsolute) {\n                    ret.base = ret.name = path.slice(1, end)\n                } else {\n                    ret.base = ret.name = path.slice(startPart, end)\n                }\n            }\n        } else {\n            if (startPart === 0 && isAbsolute) {\n                ret.name = path.slice(1, startDot)\n                ret.base = path.slice(1, end)\n            } else {\n                ret.name = path.slice(startPart, startDot)\n                ret.base = path.slice(startPart, end)\n            }\n            ret.ext = path.slice(startDot, end)\n        }\n\n        if (startPart > 0) ret.dir = path.slice(0, startPart - 1); else if (isAbsolute) ret.dir = '/'\n\n        return ret\n    },\n\n    sep: '/',\n    delimiter: ':',\n    // @ts-expect-error skip this\n    win32: null,\n    // @ts-expect-error skip this\n    posix: null\n}\n\n// @ts-expect-error read only error b/c node types\npath.posix = path\n\nfunction assertPath (path) {\n    if (typeof path !== 'string') {\n        throw new TypeError(\n            'Path must be a string. Received ' + JSON.stringify(path)\n        )\n    }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix (path, allowAboveRoot) {\n    let res = ''\n    let lastSegmentLength = 0\n    let lastSlash = -1\n    let dots = 0\n    let code\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) { code = path.charCodeAt(i) } else if (code === 47 /* / */) { break } else { code = 47 } /* / */\n        if (code === 47 /* / */) {\n            if (lastSlash === i - 1 || dots === 1) {\n                // NOOP\n            } else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /* . */ || res.charCodeAt(res.length - 2) !== 46 /* . */) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf('/')\n                        if (lastSlashIndex !== res.length - 1) {\n                            if (lastSlashIndex === -1) {\n                                res = ''\n                                lastSegmentLength = 0\n                            } else {\n                                res = res.slice(0, lastSlashIndex)\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/')\n                            }\n                            lastSlash = i\n                            dots = 0\n                            continue\n                        }\n                    } else if (res.length === 2 || res.length === 1) {\n                        res = ''\n                        lastSegmentLength = 0\n                        lastSlash = i\n                        dots = 0\n                        continue\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) { res += '/..' } else { res = '..' }\n                    lastSegmentLength = 2\n                }\n            } else {\n                if (res.length > 0) { res += '/' + path.slice(lastSlash + 1, i) } else { res = path.slice(lastSlash + 1, i) }\n                lastSegmentLength = i - lastSlash - 1\n            }\n            lastSlash = i\n            dots = 0\n        } else if (code === 46 /* . */ && dots !== -1) {\n            ++dots\n        } else {\n            dots = -1\n        }\n    }\n    return res\n}\n\nfunction _format (sep, pathObject) {\n    const dir = pathObject.dir || pathObject.root\n    const base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '')\n    if (!dir) {\n        return base\n    }\n    if (dir === pathObject.root) {\n        return dir + base\n    }\n    return dir + sep + base\n}\n\nexport default path\n"],
  "mappings": "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",
  "names": ["path", "__name", "args", "resolvedPath", "resolvedAbsolute", "cwd", "i", "assertPath", "normalizeStringPosix", "isAbsolute", "trailingSeparator", "joined", "arg", "from", "to", "fromStart", "fromEnd", "fromLen", "toStart", "toLen", "length", "lastCommonSep", "fromCode", "toCode", "out", "code", "hasRoot", "end", "matchedSlash", "ext", "start", "extIdx", "firstNonSlashEnd", "startDot", "startPart", "preDotState", "pathObject", "_format", "ret", "allowAboveRoot", "res", "lastSegmentLength", "lastSlash", "dots", "lastSlashIndex", "sep", "dir", "base", "src_default"]
}
